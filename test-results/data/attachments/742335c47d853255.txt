eventHandler<Trade>("TRADE_MODIFY", transactional = true) {
    // AUTH-COMMENT
    // A user must have the RIGHT CODE "TradeUpdate" to call this event
    // Without this call will be rejected
    permissioning {
      permissionCodes = listOf("TradeUpdate")
      // AUTH-COMMENT
      // A user must have authorisation for the country they are inserting a transaction against
      // This is applying row level insert authorisation.
      // Both the existing database record as well as the update to apply must have correct authorisation.
      auth(mapName = "COUNTRY_VISIBILITY") {
        authKeyWithUserName {
          val existingTrade= syncDb.get(Trade.byId(data.tradeId))
          key(existingTrade?.countryName, userName)
        }
      } and auth(mapName = "COUNTRY_VISIBILITY") {
        authKeyWithUserName {
          key(data.countryName, userName)
        }
      }
    }
    // AUTH-COMMENT
    //This verifies prior version of trade exists in the database - otherwise reject
    onValidate { event ->
      verify {
        entityDb hasEntry Trade.ById(event.details.tradeId)
      }
      ack()
    }
    onCommit { event ->
      val details = event.details
      // AUTH-COMMENT
      // If a user cannot see the Customer Name column they should not be able to edit this value
      // so ensure set to value in prior version - ie it is not changed
      if (!userHasRight(event.userName, "TradeViewFull")) {
        val trade = entityDb.get(Trade.ById(event.details.tradeId))!!  //The two !! are stating "we know there is a trade" as we checked in onValidate
        details.customerName = trade.customerName
      }
      entityDb.modify(details)
      ack()
    }
  }